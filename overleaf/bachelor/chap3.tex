\chapter{Proposed approach}
\pagestyle{fancy}
% \lhead{Proposed approach}
\label{solution}

The following section is dedicated to the system architecture behind the mobile application I used as a data visualization tool. Its purpose is to facilitate data reading through graphical elements (i.e. bar/line charts, tables) and group together the main features of this paper. There was a learning curve for every tool involved in the development process. As those tools are used in production by companies we all heard about (i.e. Spotify), one can imagine they are not some straight forward plug-and-play services. The entire architecture (code base and mobile application) was pushed hard towards a production-ready form. Some of problems I solved while developing this project:

\begin{itemize}
    \item {Near real-time sensor-values updates, with approx. 60 values/sec received (using web-sockets). This speed was possible only while a powerful enough machine was maintaining the system's computational business side. It was later replaced with a less powerful machine because of the costs involved in maintenance.}
    \item {Over the internet communication with a business layer spanned over multiple machines. Multiple Google services were configured and maintained during the development.}
    \item {3D printed components required a long learning curve. Many mistakes were made during the process.}
\end{itemize}

\section{System architecture}

This system architecture is divided into four layers: (A) IoT Data Sensing Layer; (B,C) Data Analysis and Reasoning Layer; (D) User Application Layer.

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 15.5cm]{figures/sa}
    \caption{System architecture}
    \label{fig:saa}
\end{figure}

% a general flowchart, conceptual model, use cases, class diagrams, sequence diagrams

\clearpage
\subsubsection{Application flow diagram}

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 15.5cm]{figures/app_flow}
    \caption{Application sequence diagram}
    \label{fig:app_flow}
\end{figure}

\subsubsection{Class diagrams}

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 14cm]{figures/class_diagram}
    \caption{Class diagram}
    \label{fig:usecases}
\end{figure}

\subsubsection{Database overview}

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 15.5cm]{figures/database_diagram}
    \caption{Database diagram}
    \label{fig:usecases}
\end{figure}

\section{Functional specifications}

When I drew a line and looked at the last 6 months, all the functionalities this application ended up having and how they interact as a result of numerous discussions, failures and discoveries, are represented in the below use case diagram:

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 14cm]{figures/usecases2}
    \caption{Usecases}
    \label{fig:usecases}
\end{figure}

\vspace{10cm}
\textbf{1. Visually check weather indicators}
\vspace{4mm}

\begin{table}[!htb]
  \begin{center}
    \label{tab:table90}
    {\begin{tabular}{p{5cm}|p{12cm}}
        \textbf{Use case specifications} & \textbf{Description}\\
         Goal & \textbullet \hspace{1mm} offer a visual representation of data measurements \\ 
         & through led based displays\vspace{2mm} \\
         Pre-condition & \textbullet \hspace{1mm} the weather station should be powered on \vspace{2mm}  \\
         Post-condition & None \vspace{2mm} \\
         Constraints/Issues/Risks & \textbullet \hspace{1mm} direct exposure to high intensity light sources may \\
         & make it difficult to read \vspace{2mm} \\
         Trigger Event(s) & \textbullet \hspace{1mm} the user should turn on the weather station \vspace{2mm} \\
         System Event(s) & None \vspace{2mm} \\
         Primary Actor & \textbullet \hspace{1mm} the user which owns the weather station\\
    \end{tabular}}
  \end{center}
\end{table}

This use case can be summarized as depicted in the following diagram.

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 14cm]{figures/mock}
    \caption{Visually check weather indicators - flow diagram}
    \label{fig:usecases}
\end{figure}

This use case was manually tested through visual confirmation of the desired action.

\vspace{4mm}
\textbf{2. Change displayed weather indicators}
\vspace{4mm}

The weather station offers a variety of display options, so that anyone with access to the physical device can check the weather measurements directly.

\begin{table}[!htb]
  \begin{center}
    \label{tab:table90}
    {\begin{tabular}{p{5.5cm} p{13cm}}
        \textbf{Use case specifications} & \textbf{Description}\\
         Goal & \textbullet \hspace{1mm} produce a visual feedback on the weather station, \\
         & changing the meaning of data displayed.\vspace{2mm} \\
         Pre-condition & \textbullet \hspace{1mm}  the weather station should be powered on and paired \\
          & to the mobile app \\
          & \textbullet \hspace{1mm} the mobile device should have a consistent internet \\
          & connection\vspace{2mm}\\
         Post-condition & None \vspace{2mm} \\
         Constraints / Issues / Risks & \textbullet \hspace{1mm} the weather station can enter an undefined state due \\ 
          & to a hardware issue\vspace{2mm} \\
         Trigger Event(s) & \textbullet \hspace{1mm} in order to preform a display update, an user must \\
         & select one of the available options that are accessible & 
         & from the "Monitor" tab, under the chart\vspace{2mm} \\
         System Event(s) & \textbullet \hspace{1mm} a message is sent from the mobile app to the weather \\
         & device \vspace{2mm} \\
         Primary Actor & \textbullet \hspace{1mm} the user which owns the weather station\\
    \end{tabular}}
  \end{center}
\end{table}

In order to make it happen, a couple of endpoints exchange messages between them. In the following code snippets one can better understand the implementation behind this use case.

\begin{lstlisting}[language=JavaScript]
// User Application Layer (Ionic Application - Monitor Page)
this.backend.ws.send(JSON.stringify({displayCode: code}))
.subscribe(
  (msg) => { ... },
  (msg) => {
      if (msg.includes('Socket connection has been closed')) {
        this.presentOkToast('Weather device cannot be reached');
      } else {
        this.presentOkToast('Cannot connect to weather device');
      }
  },
  () => { ... }
);
\end{lstlisting}

\begin{lstlisting}[language=Python]
# Reasoning Layer (Digital Ocean instance running 'consumer.py')
async def consumer_handler(websocket):
    async for message in websocket:
        if 'displayCode' in message:
            message = json.loads(message)
            data = "{\"displayCode\": " + 
                    str(message["displayCode"]) + "}"
            data = data.encode('utf-8')
            future = publisher.publish(topic_path, data=data)
            print(future.result())
        ...
\end{lstlisting}

\begin{lstlisting}[language=Python]
# IoT Data Sensing Layer: 1 (Raspberry Pi running 'publisher.py')
def display_settings():
    subscriber = pubsub_v1.SubscriberClient()
    subscription_path = subscriber.subscription_path('savage2251',  
        'flotilla1-display-settings')
    future = subscriber.subscribe(
        subscription_path, 
        callback=display_settings_callback)
    t = threading.currentThread()
    while getattr(t, 'do_run', True):
        try: future.result(timeout=5)
        except Exception as exc:
            print('Timeout refresh: ', exc)
    future.cancel()
\end{lstlisting}

\begin{lstlisting}[language=Python]
# IoT Data Sensing Layer: 2 (Open a new thread for light display execution sequence)
def display_settings_callback(message):
    global display, display_thread, options
    data = message.data.decode('utf-8')
    data = json.loads(data); display = False
    if display_thread is not None:
        display_thread.join()
    display_thread = threading.Thread(
        target=options[str(data['displayCode'])])
    display = True; display_thread.start()
    message.ack()
\end{lstlisting}

\begin{lstlisting}[language=Python]
# IoT Data Sensing Layer: 3 (Light display execution sequence; runs until the thread is canceled)
def light_display():
    global display
    start_loop = datetime.now()
    while display and (datetime.now() - start_loop).total_seconds() <= 5:
        number.set_number(int(light_v.light))
        number.update()
        matrix.set_brightness(slider.position//204 * 15 + 15)
        matrix.set_icon('L', font)
        matrix.update()
    matrix.stop()
    while display:
        number.set_number(int(light_v.light))
        number.update()
    number.stop()
\end{lstlisting}

This use case can be summarized as depicted in the following diagram.

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 14cm]{figures/mock}
    \caption{Change displayed weather indicators - flow diagram}
    \label{fig:usecases}
\end{figure}

Unit testing code snippets.

\begin{lstlisting}[language=Python]
# Testing
\end{lstlisting}

\vspace{4mm}
\textbf{2. Pair/Unpair a weather device}
\vspace{4mm}

There are a couple of reasons behind someone pairing or unpairing a weather device. One of them would be to pair a new device to the application, or stop the connection between devices as there is no reason to continue the communication.

\begin{table}[!htb]
  \begin{center}
    \label{tab:table90}
    {\begin{tabular}{p{5cm} p{12cm}}
        \textbf{Use case specifications} & \textbf{Description}\\
         Goal & \textbullet \hspace{1mm} begin or end the communication between the weather \\
         & device and the mobile application\vspace{2mm} \\
         Pre-condition & \textbullet \hspace{1mm} the weather station should be powered on and paired \\
          & or unpaired to the mobile app \\
          & \textbullet \hspace{1mm} the mobile device should have a consistent internet \\
          & connection\vspace{2mm}\\
         Post-condition & \textbullet \hspace{1mm} an user should see that the real-time data stopped \\ & updating, or it just started\vspace{2mm} \\
         Constraints / Issues / Risks & \textbullet \hspace{1mm} the weather station can enter an undefined state due \\ 
          & to a hardware issue\vspace{2mm} \\
         Trigger Event(s) & \textbullet \hspace{1mm} in order to preform a display update, an user must \\
         & select one of the available options that are accessible & 
         & from the "Monitor" tab, under the chart\vspace{2mm} \\
         Trigger Event(s) & \textbullet \hspace{1mm} a device can be paired by typing its serial number\\ 
         & in the "Pair (serial number)" input field found \\ 
         & in the "Monitor" $\rightarrow$ "Connected device" panel \\ 
         & \textbullet \hspace{1mm} to unpair a device, an user should tap on the green \\
         & cloud found on the right side of the "Currently \\
         & connected" list, found in the "Monitor" $\rightarrow$ \\
         & "Connected device" panel. \vspace{2mm} \\
         System Event(s) & \textbullet \hspace{1mm} a message is sent from the mobile app to the weather \\
         & device \vspace{2mm} \\
         Primary Actor & \textbullet \hspace{1mm} the user which owns the weather station\\
    \end{tabular}}
  \end{center}
\end{table}

In order to make it happen, a couple of endpoints exchange messages between them. In the following code snippets one can better understand the implementation behind this use case.

\begin{lstlisting}[language=JavaScript]
// User Application Layer (Ionic Application - Monitor Page > Connected Device Page)
this.backend.ws.send(JSON.stringify({emit: true})).subscribe(
    (msg) => { ... },
    (msg) => { ... },
    () => {
      let index = -1;
      for (const device of this.previouslyConnected) {
        if (device.serialNumber == this.inputSerialNumber) {
          index = this.previouslyConnected.indexOf(device);
        }
      }
      if (index >= 0) {
        const toPair = this.previouslyConnected[index];
        this.previouslyConnected.splice(index, 1);
        this.currentlyConnected.push(toPair);
      } else {
        this.currentlyConnected.push(
            {
                name: 'Flotilla', 
                location: '', 
                serialNumber: this.inputSerialNumber
            }
        );
      }
      this.localStorage.append('currentlyConnected', 
                                this.currentlyConnected);
      this.localStorage.append('previouslyConnected', 
                                this.previouslyConnected);
      this.localStorage.append('paired', [true]);
    }
);
\end{lstlisting}

\begin{lstlisting}[language=Python]
# Reasoning Layer (Digital Ocean instance running 'consumer.py')
async def consumer_handler(websocket):
    async for message in websocket:
        if "displayCode" in message:
            ...
        elif "emit" in message:
            message = json.loads(message)
            data = json.dumps(message)
            data = data.encode('utf-8')
            future = publisher.publish(topic_path, data=data)
\end{lstlisting}

\begin{lstlisting}[language=Python]
# IoT Data Sensing Layer: 1 (Light display execution sequence; runs until the thread is canceled)
def pairing():
    subscriber = pubsub_v1.SubscriberClient()
    subscription_path = subscriber.subscription_path('savage2251', 'flotilla1-pairing')
    future = subscriber.subscribe(subscription_path, callback=pairing_callback)
    try: future.result()
    except Exception as exc:
        print('Pairing exception: ', exc); future.cancel()
\end{lstlisting}

\begin{lstlisting}[language=Python]
# IoT Data Sensing Layer: 3 (Light display execution sequence; runs until the thread is canceled)
def pairing_callback(message):
    global data_communication_thread, display_settings_thread, display
    data = message.data.decode('utf-8')
    try:
        message.ack()
        data = json.loads(data)
        if 'emit' in data:
            if data['emit']:
                display = True
                data_communication_thread = threading.Thread(target=data_communication)
                display_settings_thread = threading.Thread(target=display_settings)
                data_communication_thread.start()
                display_settings_thread.start()
            elif not data['emit']:
                display = False
                data_communication_thread.do_run = False
                display_settings_thread.do_run = False
    except Exception as exc:
        print('Pairing callback exception: ', exc)
\end{lstlisting}

This use case can be summarized as depicted in the following diagram.

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 14cm]{figures/mock}
    \caption{Pair a new weather device - flow diagram}
    \label{fig:usecases}
\end{figure}

Unit testing code snippets.

\begin{lstlisting}[language=Python]
# Testing
\end{lstlisting}

\clearpage
\section{Tools \& technologies}

This project involved technologies I had very little to no experience, algorithms I only wrote for competitive programming competitions, and managing multiples machines over the internet. Mining data streams becomes a really challenging task when its data sources are real. In the following tables I will summarize some of the most interesting tools I used, talking about the decisions behind choosing them, their limitations, if any, and finally, their strengths. 

\subsection{Challenges encountered}

Before jumping into the technologies I used, there are some worth sharing development topics I want to discuss first.

\begin{table}[!htb]
  \begin{center}
    \label{tab:table3}
    \resizebox{\textwidth}{!}{\begin{tabular}{l|l|l}
      \textbf{Metric} & \textbf{MacBook Pro} & \textbf{Raspberry Pi 4}\\
      & 13-inch, 2017, Two Thunderbolt 3 ports & Model B \\
      \hline
        Processor & 2.3 GHz Intel Core i5 & 1.5 GHz, Quad-Core Broadcom BCM2711B0 \\
      \hline
        Memory & 8 GB 2133 MHz LPDDR3 & 4GB LPDDR4 3200 SDRAM \\
      \hline
        Graphics & Intel Iris Plus Graphics 640 1536 MB & 500 MHz VideoCore VI \\
      \hline
        OS & macOS Mojave 10.14.6 & Raspbian Buster @2020-02-13\\
    \end{tabular}}
    \caption{Development machines specifications}
  \end{center}
\end{table}

About raspberry.

About flotilla.

\begin{table}[!htb]
  \begin{center}
    \label{tab:table4}
    \caption{Pimoroni - Flotilla hardware}
    \resizebox{\textwidth}{!}{\begin{tabular}{l|l|l|l}
      \textbf{Purpose} & \textbf{Device name} & \textbf{Description} & \textbf{Notes}\\
      \hline
        Connection & Dock & It talks, through serial USB, to all of the Flotilla & Use up to four docks at once \\
        & & modules connected to its eight ports & ATMEGA32A4U microcontroller \\
      \hline
        Sensors & Weather & Reads temperature and pressure & BMP280 sensor \\
        & Light & Detects ambient light level & TSL2581 sensor \\
      \hline
        Display & Matrix & An 8x8 white LED matrix & White LED \\
        & Rainbow & The module has five shiny bright full-colour LEDs & Five 5050 RGB LEDs\\
    \end{tabular}}
  \end{center}
\end{table}

\subsubsection{Limitations}

Any hardware has its limitations. Below we'll discuss about them. Raspberry Pi \& Flotilla sensors - sensors error and specifications. Must read the tech sheets and make a table with their errors and other specifications.

\vspace{5cm}

\subsubsection{Operating system setup}

When I bought the first set of sensors from Pimoroni I had some issues as their library was no longer maintained, or it was not a priority for those involved at the moment. After a search, there were very few solutions, but even so, one seemed promising. After a few hours, I managed to solve the errors I had and also posted on Stackoverflow. 

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 15.5cm]{figures/sde2}
    \label{fig:sde2}
\end{figure}

After successfully installing the operating system using the balenaEtcher tool, a few modifications were made to the standard library distribution offered by Pimoroni for the Flotilla suite of sensors. The solution \cite{stovlf} was made publicly available on www.stackoverflow.com as a response to an existing question.

\begin{lstlisting}[language=bash]
user$ git clone https://github.com/pimoroni/flotilla-offline
user$ cd flotilla-offline
\end{lstlisting}

\hspace{-6mm}And then editing the install.sh file so that the line that currently reads

\begin{lstlisting}[language=bash]
case "$RELEASE" in
"9.0" | "9.1" | "9.2" | "9.3" | "9.4" | "9.5" | "9.6" | "9.7" | "9.8" | "9.9")
\end{lstlisting}

\hspace{-6mm}is changed to

\begin{lstlisting}[language=bash]
case "$RELEASE" in
"9.0" | "9.1" | "9.2" | "9.3" | "9.4" | "9.5" | "9.6" | "9.7" | "9.8" | "9.9" | "10")
\end{lstlisting}

\hspace{-6mm}We can then run 

\begin{lstlisting}[language=bash]
user$ sudo ./install
user$ curl -sS https://get.pimoroni.com/flotilla | bash
\end{lstlisting}

\hspace{-6mm} Later, I wrote an email to one of Pimoroni's developers and it got patched.

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 15.5cm]{figures/sde1}
    \label{fig:sde1}
\end{figure}

\subsubsection{Front-end message ingestion using a producer-consumer approach}

In order to deliver the real-time aspect of the entire application I used a producer-consumer layer built on web sockets \cite{ws}. The intuitive approach of searching a front-end package to consume data does not apply in a context of no REST API, therefore:
\begin{table}[!htb]
  \begin{center}
    \label{tab:table10}
    \resizebox{\textwidth}{!}{\begin{tabular}{l|l|l}
      \textbf{Component description} & \textbf{Undertaken action} & \textbf{Machine}\\
      the mobile app became a consumer & listen host:port & \\
      \hline
      a server & traffic distribution between the producer and the consumer & host:port \\
      \hline
      the PubSub subscriber became a producer & send host:port & \\
    \end{tabular}}
  \end{center}
\end{table}

\subsubsection{Architecture spanned over multiple machines}

Bla bla.
\vspace{2cm}

\subsection{Brief overview}

% language, libraries, frameworks, other technological aspects
For this project I have been using the following programming languages: . Also, it required the following frameworks: .

\section{Validation \& manual testing}

Due to its design, this application was difficult to test and required a lot of time, as the problems that occurred had to be searched on four different machines. Each part was manually tested after it has been previously unit-tested. Google Cloud Platform offered a lot of tools for a consistent and bug-free development. I used the Monitoring panel to observe the behavior of the system over a time interval of 7 days, up to 1 month. The charts also indicate offline periods as the system had to be stopped, fixed, tested and restarted. 

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 15.5cm]{figures/testing1}
    \caption{Testing using GCP's Monitoring panel}
    \label{fig:f1}
\end{figure}

While data streaming, from a development standpoint, there are things that are out of my control or I was not aware of when I started the job, so it would be wise to log everything. Sometimes, I logged things that I knew it will work, just to be sure I wasn't taking it for granted.

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 15.5cm]{figures/testing2}
    \caption{Testing using Dataflow job logs}
    \label{fig:f1}
\end{figure}

Unit-tests.

[image with results]

\clearpage
\section{Use manual}

The main objective of this application is to enable people discover fitness habits in regards to the weather conditions. Mainly, it has three tabs, each of them describing one key feature: habits, weather monitor and athlete's fitness profile. Each of these tabs have an additional panel from which one can set more specific options. 

\subsection{Real-time weather measurements visualization}

On one hand, one of the key-features of this application is the real-time weather measurements visualization panel. It allows the user to check the current data, have a better understanding of the last 24 hours by looking at the graphical representation, change the display settings on the physical device and pair or unpair a weather device. 

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 15.5cm]{figures/f1.2}
    \caption{Real-time weather measurements visualization 1}
    \label{fig:f1}
\end{figure}

In the top-left side, the "Measurements" label is followed by a toggle-type down-arrow button which slides the available measurement options when clicked. From left to right, they adapt the current display in order to present the following: temperature, air pressure, ambient light, ambient color and a comparison between temperature, air pressure and ambient light. Each measurements display has a real time component, a histogram and 2 or more display options. The histogram offers a detailed overview of a specific point, selected with a simple tap gesture over the line chart. Given that sometimes we deal with unexpected errors, and the user must know that something is not right, so that a notification will appear at the bottom on the panel. \vspace{3cm}

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 15.5cm]{figures/f1.3}
    \caption{Real-time weather measurements visualization 2}
    \label{fig:f1}
\end{figure}

In order to maintain a constant connection or stop data streaming between the mobile application and the weather device, one can use the upper-right corner button to navigate to the "Connected device" panel. Additionally, the user can get more information about the process of pairing a new device by selecting the upper-right corner button that will open an "Info" panel.

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 15.5cm]{figures/f2.1}
    \caption{Pair/Unpair weather device}
    \label{fig:f1}
\end{figure}

There are four display options one can select from the app menu: only the temperature, air pressure or light on the 7-segment display or those mention in an alternative fashion, an option for the color, and finally, a silent display option.

\begin{figure}[!htb]
    \centering
    \begin{tabular}{ccc}
        \includegraphics[width=4.5cm]{figures/faces1} &
        \includegraphics[width=4.5cm]{figures/faces2} &
        \includegraphics[width=4.5cm]{figures/faces3}
    \end{tabular}
    \caption{Display options}
    \label{fig:dops}
\end{figure}

\subsection{Fitness tracker statistics visualization}

On the other hand, we have a panel dedicated to fitness statistics in which one can check this year's stats and the over all stats. Using the upper-right corner button, one can sync its Strava account with the application. After that, it can see the count, distance, moving time, elevation gain and average speed for this year's events and also for all its activities ever recorded on Strava. In addition, it can see its recent events.

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 15.5cm]{figures/f2}
    \caption{Fitness statistics visualization}
    \label{fig:f2}
\end{figure}

\clearpage
\subsection{Fitness habits visualization}

Finally, 

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 15.5cm]{figures/f3b}
    \caption{Fitness habits visualization}
    \label{fig:f3}
\end{figure}

\section{Summation}

TBA


